<!DOCTYPE html>
<html lang="en" dir="ltr">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="initial-scale=1, width=device-width">
    <title>Algorithms: An Introduction</title>

    <!-- CSS -->
    <link rel="stylesheet" href="../css/styles.css">

    <!-- Google Fonts: Montserrat and Ubuntu. Currently not used.-->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&family=Sacramento&family=Ubuntu:ital,wght@0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap"
        rel="stylesheet">

    <!-- Bootstrap -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-Zenh87qX5JnK2Jl0vWa8Ck2rdkQ2Bzep5IDxbcnCeuOxjzrPF/et3URy9Bv1WTRi" crossorigin="anonymous">


    <!-- Font awesome -->
    <script src="https://kit.fontawesome.com/181c7bc6bd.js" crossorigin="anonymous"></script>


    <!-- Javascript -->
    <script src="../index.js" charset="utf-8"></script>

</head>



<body>


    <section id="nav">
        <!-- <div class="container-fluid"> -->
        <nav class="navbar navbar-expand-lg navbar-dark">

            <button class="navbar-toggler" type="button" data-bs-toggle="collapse"
                data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false"
                aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <!-- AddToAny BEGIN -->
            <div class="a2a_kit a2a_kit_size_32 a2a_default_style" style="float: left; margin-left: 20px;">
                <!-- <a class="a2a_dd" href="https://www.addtoany.com/share"></a> -->
                <a class="a2a_button_linkedin"></a>
                <a class="a2a_button_facebook"></a>
                <a class="a2a_button_whatsapp"></a>
                <a class="a2a_button_twitter"></a>
                <a class="a2a_button_email"></a>
                <a class="a2a_button_google_gmail"></a>
            </div>
            <script async src="https://static.addtoany.com/menu/page.js"></script>
            <!-- AddToAny END -->

            <!-- Links at top right will collapse -->
            <div class="collapse navbar-collapse" id="navbarSupportedContent">

                <ul class="navbar-nav ms-auto">

                    <li class="nav-item">
                        <a class="nav-link" href="../index.html">Home</a>
                    </li>

                    <li class="nav-item">
                        <a class="nav-link" href="../index.html#projects">Projects</a>
                    </li>

                    <li class="nav-item">
                        <a href="../index.html#blog" class="nav-link">Blog</a>
                    </li>

                    <li class="nav-item">
                        <a href="../index.html#contact" class="nav-link">Contact</a>
                    </li>

                </ul>
            </div>

        </nav>

        <!-- </div> -->
    </section>

    <section>
        <div class="container-fluid">
            <div class="row">


                <div class="col-lg-12">


                    <h1 style="text-align:center" class="intro-padding">Algorithms: An Introduction (Part 1)</h1>

                </div>
            </div>
        </div>
        <div class="container">

            <div class="row">
                <div class="col-lg-12">
                    <figure style="text-align: center;">
                        <img src="../Images/algorithms/algorithms1.webp" alt="algorithmscover" width="700"
                            height="auto">
                    </figure>
                </div>
            </div>
        </div></br>
        <p>13 Jan '24</p>
        <p>
            This article introduces the basic algorithms that one would usually cover in a Data Structures and
            Algorithms course. It's not meant to be a comprehensive or technical piece, but rather to cover the big
            ideas on
            algorithms.I decided to write this article as a form of revision for the DSA book, <em>Ace Your Next Coding
                Interview by Learning Algorithms through Programming and Problem Solving</em>, which is written by
            <em>Alexander
                Kulikov</em> and <em>Pavel Pevzner</em>. The contents in the book are rephrased to demonstrate my
            understanding. It is supplemented with my prior knowledge, other
            books and websites.
            I hope that people who read this will find it useful as well. Ready? Let's begin... :)
        </p>

        <p>What is an algorithm? An algorithm is a sequence of instructions that one must perform in order to solve a
            well-formulated problem (Kulikov & Pevzner). An algorithm is not confined to the domain of computer science.
            Think of cooking recipes and finding the highest common factor (greatest common divisor). One is in the
            domain of cooking and another is in mathematics, although one can solve the HCF by programming the algorithm
            in
            a computer.</p>

        <p><u>Running Time of Algorithms</u></p>

        <p>
            Given the choice between two or more algorithms that produce the same output barring any side-effects,
            computer scientists and programmers will want to
            implement the fastest algorithms as it saves time. Measuring the true running time of algorithms is not a
            scalable and feasible approach as it is affected by hardware factors like processor speeds, which is
            constantly improving. A better measure would be to calculate the algorithm's total number of operations.
            However, it is not easy to calculate the exact number of operations. A more feasible way would be to have a
            <em>high-level understanding</em> of the <em>growth</em> of the algorithm's operation count as the size of
            the
            input increases (Kulikov & Pevzner). What does it mean then? In studying the running time of algorithms, one
            is
            not interested in small values of input,
            <i>n</i>. What is of interest is the measure of growth of the algorithm as <i>n</i> becomes large.
        </p>

        <p><u>Big-Oh Notation</u></p>
        <p>The Big-Oh notation is a function which defines the limits of the growth of the algorithm. It is a measure of
            the algorithm's worse case efficiency. For example, if an algorithm has a Big-Oh represented by the
            function
            <i>f</i>(<i>n</i>) = <i>O</i>(<i>n</i><sup>2</sup>), it would mean <i>f</i>(<i>n</i>) does not grow faster
            than a function
            with a leading term of <i>cn</i><sup>2</sup>. In
            Big-Oh notations, the
            coefficient and trailing terms are ignored. A more precise definition of the Big-Oh can be defined from the
            following. Consider two algorithms with
            running times of <i>f</i>(<i>n</i>) and <i>g</i>(<i>n</i>), where <i>n</i> is the input size. The function
            <i>f</i> grows no faster than <i>g</i> if there exists a constant <i>c</i> such that <i>f</i>(<i>n</i>) &le;
            <i>c.g</i>(<i>n</i>), leading to the notation, <i>f</i> = <i>O</i>(<i>g</i>).
        </p>

        <p>In the sections that follow, we will look at some common algorithm designs. Many algorithms are
            created based on these algorithmic designs.</p><br>

        <p><u>A) Brute-Force Algorithms</u></p>

        <p>Brute-Force Algorithms are also known as exhaustive search algorithms. In searching for an item, it would
            traverse an entire map or maze without any strategy. While it
            almost
            certainly ensures the item is found, it is inefficient. In designing algorithms, one should as much as
            possible avoid brute-force algorithms.</p>

        <p><u>B) Branch and Bound Algorithms</u></p>

        <p>Branch and bound is an algorithm design which is generally used for solving combinatorial
            optimisation problems. These problems are typically exponential in terms of time complexity and may require
            exploring all possible permutations in worst case. A famous example is The Travelling Salesman Problem
            (TSP). The
            problem statement is as such:</p>
        <p><i>"Given a set of cities and the distances between each pair of cities, a salesman uses the shortest
                distance
                to visit each city exactly once and returns to the starting city."</i></p>

        <p>There is no algorithm that can solve all instances of TSP optimally. The branch and bound algorithm works by
            systematically exploring the solution space, keeping track of
            promising candidates, and eliminating branches of the search space that cannot lead to an optimal solution.
            For TSP, it involves techniques and heuristics to efficiently explore the solution space. While it may not
            guarantee finding the optimal solution for large instances due to the Nondeterministic Polynomial (NP)-hard
            nature of the problem, branch
            and bound algorithms can significantly improve the efficiency of the search process. Click <a
                href=https://deepai.org/machine-learning-glossary-and-terms/nondeterministic-polynomial-time#:~:text=Nondeterministic%20Polynomial%20Time%20is%20a,what%20can%20be%20efficiently%20computed.>here</a>
            for an interesting read on understanding NP problems.
        </p>

        <p><u>C) Greedy Algorithms</u></p>

        <p>Greedy algorithms are iterative optimisation algorithms that make locally optimal choices at each step with
            the hope of finding a global optimum. While this strategy often leads to correct solutions and works well
            for many problems, it does not guarantee an optimal solution in all cases. An example in which greedy
            algorithm paradigm is used is in scheduling problems.
        </p>

        <div class="container">

            <div class="row">
                <div class="col-lg-12">
                    <figure style="text-align: center;">
                        <img src="../Images/algorithms/scheduling.webp" alt="scheduling" width="700" height="auto">
                        <figcaption>Image from <em>Ace Your Next Coding
                                Interview by Learning Algorithms through Programming and Problem Solving </em>(
                            Kulikov and Pevzner) </figcaption>
                    </figure>
                </div>
            </div>
        </div></br>
        <p><u>i) Scheduling Problem</u></p>
        <p>In the scheduling problem, the objective is to fit in as many bookings for a meeting room. A greedy approach
            could be to select the meeting with the shortest duration, remove meetings that overlap it, and iterate.
            This greedy approach algorithm seems sensible but it doesn't always work, as seen in the image below.</p>

        <div class="container">

            <div class="row">
                <div class="col-lg-12">
                    <figure style="text-align: center;">
                        <img src="../Images/algorithms/greedysub.webp" alt="scheduling" width="700" height="auto">
                        <figcaption>Image from <em>Ace Your Next Coding
                                Interview by Learning Algorithms through Programming and Problem Solving </em>(
                            Kulikov and Pevzner) </figcaption>
                    </figure>
                </div>
            </div>
        </div></br>
        <p>Let's try again then. Another sensible approach would be to select the meeting with the earliest start time,
            remove overlaps, and iterate. Again, it doesn't always work, as seen in the image below.</p>
        <div class="container">

            <div class="row">
                <div class="col-lg-12">
                    <figure style="text-align: center;">
                        <img src="../Images/algorithms/greedysub2.webp" alt="scheduling" width="700" height="auto">
                        <figcaption>Image from <em>Ace Your Next Coding
                                Interview by Learning Algorithms through Programming and Problem Solving </em>(
                            Kulikov and Pevzner) </figcaption>
                    </figure>
                </div>
            </div>
        </div></br>
        <p>Having seen two greedy algorithms which may not work for all cases, is there a solution to it? The answer is
            yes. By selecting the right endpoint which is the smallest among all right endpoints, removing all intervals
            that overlap, and then iterating it, one would get the optimal solution to the scheduling problem.</p>

        <p><u>ii) Haversack Greedy Algorithm</u></p>

        <div class="container">

            <div class="row">
                <div class="col-lg-12">
                    <figure style="text-align: center;">
                        <img src="../Images/algorithms/knapsack.svg" alt="haversack" width="500" height="auto">
                        <figcaption> </figcaption>
                    </figure>
                </div>
            </div>
        </div></br>

        <p>Let's look at another greedy algorithm problem. The Haversack Greedy Algorithm, also known as the Knapsack
            Greedy Algorithm, is an approach used to solve the knapsack problem, a classic optimisation problem in
            computer science. The problem is described as follows:</p>

        <p> There is a set of items and a knapsack with a maximum weight capacity. Each item has a weight and value. The
            weight of an item could be represented by its actual weight or how much volume it occupies. The value can be
            thought of as a utility function like monetary value.
            The goal is to maximise the total value of items placed in the knapsack without exceeding its weight
            capacity.</p>

        <p>
            The greedy algorithm works by iteratively selecting items to include in the
            knapsack based on a greedy criterion. The criterion involves selecting items with the highest
            value-to-weight ratio first, as this maximises the value gained per unit of weight.
        </p>
        <p>Here's a step-by-step description of the Haversack Greedy Algorithm: </p>

        <div class="container">
            <ol>
                <li>
                    <em><b>Sort items: </b></em>Start by sorting all items in decreasing order of their value-to-weight
                    ratio. This
                    ratio is
                    calculated by dividing the value of each item by its weight.
                </li>
                <li>
                    <em><b>Iterative selection:</b></em>Iterate through the sorted list of items. At each iteration,
                    select
                    the
                    item
                    with
                    the
                    highest value-to-weight ratio that can still fit into the knapsack without exceeding its weight
                    capacity.
                </li>
                <li>
                    <em><b>Update knapsack:</b></em> Add the selected item to the knapsack and update the remaining
                    capacity
                    of the
                    knapsack by
                    subtracting the weight of the selected item.
                </li>
                <li>
                    <em><b>Repeat:</b></em> Continue the iteration until either the knapsack is full or
                    there are no more items to consider.
                </li>

            </ol>
        </div>

        <p>
            The Haversack Greedy Algorithm provides a relatively simple and efficient solution to the knapsack problem,
            particularly when the items are sorted based on their value-to-weight ratios. However, it's important to
            note that this algorithm does not always guarantee an optimal solution. For example, it may overlook certain
            combinations of items that could yield a higher total value than simply selecting items based solely on
            their individual value-to-weight ratios. The reason why a sub-optimal solution may be selected is due to the
            constraint set in the algorithm. Instead of exploring all possible solutions, the greedy constraint (e.g.
            highest value-to-weight ratio) restricts the search space for the optimal solution.
        </p>
        <div class="container">
            <pre class="preStyle">
    Change(money, Denominations):
        numCoins <- 0
        while money > 0:
            maxCoin <- largest among Denominations that does not exceed money
            money <- money - maxCoin
            numCoins <- numCoins + 1
        return numCoins
    </pre>
        </div>
        <p>The Change Greedy Algorithm displayed above is another example where the greedy algorithm produces a
            sub-optimal solution on
            using certain values e.g. Change(8,[1,4,6]). The algorithm above will result in 3 coins (6+1+1) when it can
            be achieved with a better result of 2 coins (4+4).</p>
        <p>In conclusion while greedy algorithms offer a straightforward approach to solving optimisation problems and
            are often efficient, it's important to carefully analyse the problem to
            determine whether a greedy algorithm is appropriate and whether its solution is optimal.</p><br>


        <p>
            <u>D) Dynamic Programming Algorithms</u>
        </p>

        <p>Dynamic programming organises computations to avoid recomputing values that you already know, which can often
            save a great deal of time.</p>

        <p>Dynamic programming is a method for solving complex problems by breaking them down into smaller, more
            manageable subproblems
            and solving each subproblem only <b>once</b>, thus saving time. The solutions to these subproblems are
            reused as needed. It is usually used in optimisation problems where the solution can
            be obtained by combining solutions to overlapping subproblems.</p>
        <p>Let us analyse dynamic programming algorithms using the "Rocks" game. There are variations to this game and
            we will look into one of them; There are two piles of ten rocks each. In each turn, a player may remove
            either
            one rock (from either pile) or two rocks (one from each pile). The player who takes the last rock wins the
            game.</p>

        <p>Let's visualise the pile of rocks using a 10 x 10 grid table, called <i>R</i>. The row and column each
            represents
            a pile. We can generalise the 10 x 10 table to a <i>n</i> x <i>m</i> table, implying <i>n</i> rocks in one
            pile and <i>m</i> rocks in the other. If, at the current state, Player 1 always wins the <i>n</i> + <i>m</i>
            game no matter what
            Player 2 does, then <i>R</i>(<i>n</i>,<i>m</i>) = <i>W</i> (Mark grid (<i>n</i>,<i>m</i>) with <i>W</i>).
            Likewise, <i>R</i>(<i>n</i>,<i>m</i>) = <i>L</i> if at the current state, Player 1 can never win against
            Player 2 (Mark grid (<i>n</i>,<i>m</i>) with <i>L</i>).</p>

        <p>Having learnt how the cells should be filled up, we can start filling up the table. Cells (1,0), (1,1) and
            (0,1) would always result in Player 1 winning as Player 1 can make moves to remove all rocks based on the
            rules
            provided. We can fill up (2,0) next. As Player 1 can only remove 1 rock, it will result in (1,0),
            ensuring that Player 2 wins. Thus (2,0) is marked L. (0,2) is also marked L as it is just a matter of
            removing from the bottom pile instead of the top pile, all else being equal (symmetrical).</p>

        <div class="container">
            <div class="row">
                <div class="col-lg-6">
                    <figure style="text-align: center;">
                        <img src="../Images/algorithms/dp1.webp" alt="dp1" style="max-width: 100%; display: block;">
                        <figcaption>a) States where Player 1 always wins</figcaption>
                    </figure>
                </div>
                <div class="col-lg-6">
                    <figure style="text-align: center;">
                        <img src="../Images/algorithms/dp2.webp" alt="dp2" style="max-width: 100%; display: block;">
                        <figcaption>b) States where Player 2 always wins (green boxes)</figcaption>
                    </figure>
                </div>
            </div>
        </div></br>

        <p>We have filled up 5 boxes so far. Let's proceed to fill up (2,1). Player 1 can make one of 3 moves, resulting
            in (2,0), (1,0) or (1,1). Assuming the game is played optimally (Player 1 removes 1 rock from the bottom
            pile resulting in (2,0)), (2,1) results in a
            winning move for Player
            1 as Player 2 can only remove 1 out of 2 rocks from the bottom pile. Thus <i>R</i>(<i>2</i>,<i>1</i>) is
            marked W. As (1,2) is symmetrical to (2,1), <i>R</i>(<i>1</i>,<i>2</i>) is also marked W. </p>

        <div class="container">

            <div class="row">
                <div class="col-lg-12">
                    <figure style="text-align: center;">
                        <img src="../Images/algorithms/dp3.webp" alt="haversack" width="500" height="auto">
                        <figcaption>c) <i>R</i>(<i>2</i>,<i>1</i>) and <i>R</i>(<i>1</i>,<i>2</i>) = W </figcaption>
                    </figure>
                </div>
            </div>
        </div></br>

        <p>We use the same approach of determining the winner for the other cells.
            In
            the (2,2) case, Player 1 can make three different moves that lead to (2,1), (1,2) and (1,1). As we have
            already filled up the cells for these states with W, they would be winning states for the next Player, which
            is Player 2. Thus <i>R</i>(<i>2</i>,<i>2</i>) is
            marked L.</p>

        <div class="container">

            <div class="row">
                <div class="col-lg-12">
                    <figure style="text-align: center;">
                        <img src="../Images/algorithms/dp4.webp" alt="haversack" width="500" height="auto">
                        <figcaption>d) <i>R</i>(<i>2</i>,<i>2</i>) = L </figcaption>
                    </figure>
                </div>
            </div>
        </div></br>


        <p>How can the table be filled up systematically
            (algorithmically) if there are <i>n</i> by <i>m</i> entries in the table? A commonly-used technique in
            problem-solving is to start with small values, scale it up, and notice if there is a pattern. If there is,
            it means there is an algorithmic approach to solving the problem. This is exactly what we have been doing.
            One can fill up the
            rest of table using the same reasoning.</p>
        <p>In the Rocks game, a pattern can be established using this
            approach. We can quickly fill up the table by noticing that whenever a cell is marked L, the cells above,
            diagonally left and directly left are marked W. The completed table has the following entries below.
        </p>

        <div class="container">

            <div class="row">
                <div class="col-lg-12">
                    <figure style="text-align: center;">
                        <img src="../Images/algorithms/dp5.webp" alt="haversack" width="500" height="auto">
                        <figcaption></figcaption>
                    </figure>
                </div>
            </div>
        </div></br>

        <p>The Rocks game demonstrates dynamic programming where a complex problem is solved by broking it down into
            smaller subproblems. The solutions to the subproblems are used to solve the bigger problem and are used as
            needed. </p>


        <p>We have gotten a taste of four approaches to designing algorithms, namely brute force, branch-and-bound,
            greedy algorithms and dynamic programming. Going through these algorithms, I realise that they were akin to
            solving puzzles. Those who enjoy puzzles will find a knack in this field. This concludes Part 1 of the
            Algorithms: An Introduction blog. In Part 2, we will explore Recursive
            Algorithms, Divide and Conquer Algorithms and Randomised Algorithms. Till next time. &#128522;</p>

        <div class="container">

            <div class="row">
                <div class="col-lg-12">
                    <figure style="text-align: center;">
                        <img src="../Images/algorithms/algorithms2.webp" alt="haversack" width="500" height="auto">
                        <figcaption></figcaption>
                    </figure>
                </div>
            </div>
        </div></br>

    </section>


    <hr>


    <section id=footer>

        <table>

            <tr>
                <td>

                    <a class="footer-style" href="../index.html"> Home</a>

                </td>
                <td>

                    <a class="footer-style" href="../index.html#projects"> Projects</a>

                </td>

                <td>

                    <a class="footer-style" href="../index.html#blog"> Blog</a>

                </td>
            </tr>

        </table><br>
    </section>

    <!-- Bootstrap - Javascript -->
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.6/dist/umd/popper.min.js"
        integrity="sha384-oBqDVmMz9ATKxIep9tiCxS/Z9fNfEXiDAYTujMAeBAsjFuCZSmKbSSUnQlmh/jp3"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/js/bootstrap.min.js"
        integrity="sha384-IDwe1+LCz02ROU9k972gdyvl+AESN10+x7tBKgc9I5HFtuNz0wWnPclzo6p9vxnk"
        crossorigin="anonymous"></script>


</body>

</html>