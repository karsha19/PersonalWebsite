<!DOCTYPE html>
<html lang="en" dir="ltr">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="initial-scale=1, width=device-width">
    <title>Algorithms: An Introduction</title>

    <!-- CSS -->
    <link rel="stylesheet" href="../css/styles.css">

    <!-- Google Fonts: Montserrat and Ubuntu. Currently not used.-->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&family=Sacramento&family=Ubuntu:ital,wght@0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap"
        rel="stylesheet">

    <!-- Bootstrap -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-Zenh87qX5JnK2Jl0vWa8Ck2rdkQ2Bzep5IDxbcnCeuOxjzrPF/et3URy9Bv1WTRi" crossorigin="anonymous">


    <!-- Font awesome -->
    <script src="https://kit.fontawesome.com/181c7bc6bd.js" crossorigin="anonymous"></script>


    <!-- Javascript -->
    <script src="../index.js" charset="utf-8"></script>

</head>



<body>


    <section id="nav">
        <!-- <div class="container-fluid"> -->
        <nav class="navbar navbar-expand-lg navbar-dark">

            <button class="navbar-toggler" type="button" data-bs-toggle="collapse"
                data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false"
                aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>

            <!-- Links at top right will collapse -->
            <div class="collapse navbar-collapse" id="navbarSupportedContent">

                <ul class="navbar-nav ms-auto">

                    <li class="nav-item">
                        <a class="nav-link" href="../index.html">Home</a>
                    </li>

                    <li class="nav-item">
                        <a class="nav-link" href="../index.html#projects">Projects</a>
                    </li>

                    <li class="nav-item">
                        <a href="../index.html#blog" class="nav-link">Blog</a>
                    </li>

                    <li class="nav-item">
                        <a href="../index.html#contact" class="nav-link">Contact</a>
                    </li>

                </ul>
            </div>

        </nav>

        <!-- </div> -->
    </section>

    <section>
        <div class="container-fluid">
            <div class="row">


                <div class="col-lg-12">


                    <h1 style="text-align:center" class="intro-padding">Algorithms: An Introduction</h1>

                </div>
            </div>
        </div>
        <div class="container">

            <div class="row">
                <div class="col-lg-12">
                    <figure style="text-align: center;">
                        <img src="../Images/algorithms/algorithms1.png" alt="algorithmscover" width="700" height="auto">
                    </figure>
                </div>
            </div>
        </div></br>
        <p>
            This article introduces the basic algorithms that one would usually cover in a Data Structures and
            Algorithms course. It's not meant to be a comprehensive or technical piece, but rather to cover the big
            ideas on
            algorithms.I decided to write this article as a form of revision for the DSA book, <em>Ace Your Next Coding
                Interview by Learning Algorithms through Programming and Problem Solving</em>, which is written by
            <em>Alexander
                Kulikov</em> and <em>Pavel Pevzner</em>. The contents in the book are rephrased to demonstrate my
            understanding. It is supplemented with my prior knowledge, other
            books and websites.
            I hope that people who read this will find it useful as well. Ready? Let's begin... :)
        </p>

        <p>What is an algorithm? An algorithm is a sequence of instructions that one must perform in order to solve a
            well-formulated problem (Kulikov & Pevzner). An algorithm is not confined to the domain of computer science.
            Think of cooking recipes and finding the highest common factor (greatest common divisor). One is in the
            domain of cooking and another is in mathematics, although one can solve the HCF by programming the algorithm
            in
            a computer.</p>

        <p><u>Running Time of Algorithms</u></p>

        <p>
            Given the choice between two or more algorithms that produce the same output barring any side-effects,
            computer scientists and programmers will want to
            implement the fastest algorithms as it saves time. Measuring the true running time of algorithms is not a
            scalable and feasible approach as it is affected by hardware factors like processor speeds, which is
            constantly improving. A better measure would be to calculate the algorithm's total number of operations.
            However, it is not easy to calculate the exact number of operations. A more feasible way would be to have a
            <em>high-level understanding</em> of the <em>growth</em> of the algorithm's operation count as the size of
            the
            input increases (Kulikov & Pevzner). What does it mean then? In studying the running time of algorithms, one
            is
            not interested in small values of input,
            <i>n</i>. What is of interest is the measure of growth of the algorithm as <i>n</i> becomes large.
        </p>

        <p><u>Big-Oh Notation</u></p>
        <p>The Big-Oh notation is a function which defines the limits of the growth of the algorithm. It is a measure of
            the algorithm's worse case efficiency. For example, if an algorithm has a Big-Oh represented by the
            function
            <i>f</i>(<i>n</i>) = <i>O</i>(<i>n</i><sup>2</sup>), it would mean <i>f</i>(<i>n</i>) does not grow faster
            than a function
            with a leading term of <i>cn</i><sup>2</sup>. In
            Big-Oh notations, the
            coefficient and trailing terms are ignored. A more precise definition of the Big-Oh can be defined from the
            following. Consider two algorithms with
            running times of <i>f</i>(<i>n</i>) and <i>g</i>(<i>n</i>), where <i>n</i> is the input size. The function
            <i>f</i> grows no faster than <i>g</i> if there exists a constant <i>c</i> such that <i>f</i>(<i>n</i>) &le;
            <i>c.g</i>(<i>n</i>), leading to the notation, <i>f</i> = <i>O</i>(<i>g</i>).
        </p>

        <p>In the sections that follow, we will look at some common algorithm designs. Many algorithms are
            created based on these algorithmic designs.</p><br>

        <p><u>A) Brute-Force Algorithms</u></p>

        <p>Brute-Force Algorithms, also known as exhaustive search algorithms, are as what its name implies. For
            example, in searching for an item, it would traverse an entire map or maze without any strategy. While it
            almost
            certainly ensures the item is found, it is inefficient. In designing algorithms, one should as much as
            possible avoid brute-force algorithms.</p>

        <p><u>B) Branch and Bound Algorithms</u></p>

        <p>Branch and bound is an algorithm design which is generally used for solving combinatorial
            optimisation problems. These problems are typically exponential in terms of time complexity and may require
            exploring all possible permutations in worst case. A famous example is The Travelling Salesman Problem
            (TSP). The
            problem statement is as such:</p>
        <p><i>"Given a set of cities and the distances between each pair of cities, a salesman uses the shortest
                distance
                to visit each city exactly once and returns to the starting city."</i></p>

        <p>There is no algorithm that can solve all instances of TSP optimally. The branch and bound algorithm works by
            systematically exploring the solution space, keeping track of
            promising candidates, and eliminating branches of the search space that cannot lead to an optimal solution.
            For TSP, it involves techniques and heuristics to efficiently explore the solution space. While it may not
            guarantee finding the optimal solution for large instances due to the NP-hard nature of the problem, branch
            and bound algorithms can significantly improve the efficiency of the search process.
        </p>

        <p><u>C) Greedy Algorithms</u></p>

        <p>Greedy algorithms are iterative optimisation algorithms that make locally optimal choices at each step with
            the hope of finding a global optimum. While this strategy often leads to correct solutions and works well
            for many problems, it does not guarantee an optimal solution in all cases. An example in which greedy
            algorithm paradigm is used is in timetabling or scheduling problems.
        </p>

        <div class="container">

            <div class="row">
                <div class="col-lg-12">
                    <figure style="text-align: center;">
                        <img src="../Images/algorithms/scheduling.png" alt="scheduling" width="700" height="auto">
                        <figcaption>Image from <em>Ace Your Next Coding
                                Interview by Learning Algorithms through Programming and Problem Solving </em>(
                            Kulikov and Pevzner) </figcaption>
                    </figure>
                </div>
            </div>
        </div></br>

        <p>Dynamic Programming Algorithms</p>

        <p></p>

        <p>Recursive Algorithms</p>

        <p></p>

        <p>Divide and Conquer Algorithms</p>

        <p></p>


        <p>Randomised Algorithms</p>

        <p></p>









    </section>


    <hr>


    <section id=footer>

        <table>

            <tr>
                <td>

                    <a class="footer-style" href="../index.html"> Home</a>

                </td>
                <td>

                    <a class="footer-style" href="../index.html#projects"> Projects</a>

                </td>

                <td>

                    <a class="footer-style" href="../index.html#blog"> Blog</a>

                </td>
            </tr>

        </table><br>
    </section>

    <!-- Bootstrap - Javascript -->
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.6/dist/umd/popper.min.js"
        integrity="sha384-oBqDVmMz9ATKxIep9tiCxS/Z9fNfEXiDAYTujMAeBAsjFuCZSmKbSSUnQlmh/jp3"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/js/bootstrap.min.js"
        integrity="sha384-IDwe1+LCz02ROU9k972gdyvl+AESN10+x7tBKgc9I5HFtuNz0wWnPclzo6p9vxnk"
        crossorigin="anonymous"></script>


</body>

</html>